// Google Drive push helper for NotebookLM
// Uploads structured log as a text file to user's S101 Dust Logs folder
// NotebookLM can source documents from Google Drive folders

interface StructuredLog {
  summary: string
  workCompleted: string[]
  issues: string[]
  safety: string[]
  nextSteps: string[]
  tags: string[]
  jobType: string
  structuredLog: string
}

async function refreshAccessToken(refreshToken: string): Promise<string> {
  const res = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: process.env.GOOGLE_CLIENT_ID!,
      client_secret: process.env.GOOGLE_CLIENT_SECRET!,
      refresh_token: refreshToken,
      grant_type: 'refresh_token',
    }),
  })

  if (!res.ok) throw new Error('Failed to refresh Google token')
  const data = await res.json()
  return data.access_token
}

export async function pushLogToDrive(
  storedToken: string,
  folderId: string,
  logData: {
    projectName: string
    address: string
    date: string
    structured: StructuredLog
  }
) {
  const { projectName, address, date, structured } = logData

  // Refresh token if it's a refresh_token (longer than access tokens)
  let accessToken = storedToken
  if (storedToken.length > 200) {
    // Likely a refresh token — get fresh access token
    try {
      accessToken = await refreshAccessToken(storedToken)
    } catch {
      // Use stored token as-is if refresh fails
    }
  }

  const fileName = `${date}_${projectName.replace(/[^a-z0-9]/gi, '_')}.txt`
  const fileContent = formatLogForDrive(logData)

  // Upload as plain text — NotebookLM ingests text files from Drive
  const metadata = {
    name: fileName,
    parents: [folderId],
    mimeType: 'text/plain',
  }

  const boundary = '-------314159265358979323846'
  const body = [
    `--${boundary}`,
    'Content-Type: application/json; charset=UTF-8',
    '',
    JSON.stringify(metadata),
    `--${boundary}`,
    'Content-Type: text/plain',
    '',
    fileContent,
    `--${boundary}--`,
  ].join('\r\n')

  const res = await fetch(
    'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': `multipart/related; boundary="${boundary}"`,
        'Content-Length': Buffer.byteLength(body).toString(),
      },
      body,
    }
  )

  if (!res.ok) {
    const err = await res.text()
    throw new Error(`Google Drive upload error: ${err}`)
  }

  return res.json()
}

function formatLogForDrive(logData: {
  projectName: string
  address: string
  date: string
  structured: StructuredLog
}): string {
  const { projectName, address, date, structured } = logData
  const lines: string[] = [
    `SUPERINTENDENT101 — FIELD LOG`,
    `Date: ${date}`,
    `Project: ${projectName}`,
    `Location: ${address}`,
    `Job Type: ${structured.jobType}`,
    `Tags: ${structured.tags.join(', ')}`,
    '',
    `SUMMARY`,
    structured.summary,
    '',
  ]

  if (structured.safety.length) {
    lines.push('SAFETY OBSERVATIONS')
    structured.safety.forEach(s => lines.push(`  • ${s}`))
    lines.push('')
  }

  if (structured.workCompleted.length) {
    lines.push('WORK COMPLETED')
    structured.workCompleted.forEach(w => lines.push(`  • ${w}`))
    lines.push('')
  }

  if (structured.issues.length) {
    lines.push('ISSUES / RFIs')
    structured.issues.forEach(i => lines.push(`  • ${i}`))
    lines.push('')
  }

  if (structured.nextSteps.length) {
    lines.push('NEXT STEPS')
    structured.nextSteps.forEach(n => lines.push(`  • ${n}`))
    lines.push('')
  }

  lines.push('---')
  lines.push('Generated by Superintendent101 Dust Logs')

  return lines.join('\n')
}
